# 1. 数据类型
    Go 是 静态类型的，这意味着 一旦定义了变量类型，它就只能存储该类型的数据。
## 1.1. bool 类型
    1. 表示布尔值，只有 true 或 false 两个取值
    2. 默认值为 false
```cgo
    var b1 bool = true //带有初始值的 类型声明
    var b2 = true      // 带初始值的 无类型声明
    var b3 bool        // 不带初始值的类型声明  默认为 false
    b4 := true         // 自动类型推断
    
    fmt.Println(b1) // true
    fmt.Println(b2) // true
    fmt.Println(b3) // false
    fmt.Println(b4) // true
```

## 1.2. 数值
     整数类型、浮点类型、复数类型 和 字符类型
### 1.2.1. 整数
    整数数据类型 用于 存储没有小数的整数，如 35、-50 或 1345000
#### ①. int
    用 int 关键字之一声明的有符号整数可以存储正数和负数

    因为有一位表示正负(0/1)，故取值范围应在(2的n-1次方)
    又因为0占正数的一个位置所以最大取值是(2的n-1次方)-1
##### a. int
    大小取决于平台（32位平台占32位，64位平台占64位）
##### b. int8
    8位：取值范围在[-128, 127]
##### c. int16
    16位：取值范围在[-32768, 32767]
##### d. int32
##### e. int64
##### f. rune32
    32位：是int32的别名用于处理 Unicode字符

#### ②. uint
    使用 uint 关键字声明的无符号整数只能存储非负值
##### a. uint
    大小取决于平台（32位平台占32位，64位平台占64位）
##### b. uint8
    8位：取值范围在[0, 255]
##### c. uint16
    16位：取值范围在[0, 65535]
##### d. uint32
##### e. uint64
##### f. byte
    8位：uint8 的一个 别名
##### g. uintptr
    取决于平台：表示指针类型

#### ③. 整数字面量
    整数字面值是表示整数常量的数字序列。可选前缀设置非十进制基数。为了便于阅读，下划线字符 _ 可能出现在 基本前缀之后 或 连续数字之间；这样的下划线不会改变字面值
- 0b 或 0B 表示二进制序列
- 0o 或 0O 表示八进制序列
- 0x 或 0X 表示十六进制。在十六进制文字中,字母a到f表示值10到15
- 单个 0 被视为十进制零

### 1.2.2. 浮点类型
    浮点数据类型 用于 存储带小数点的正数和负数
    浮点数在计算机中的表示方法遵循IEEE 754标准
    浮点类型的 默认类型是 float64。如果不指定类型，则类型为 float64
    float32 与 float64 类型的变量不能相互赋值。是两个不同的数据类型

#### 1.2.2.1 介绍
- float32：32位 = 4字节*8 小数部分只能精确到后面6位，加上小数点前的一位，总的有效数字为7位。
- float64：64位 = 8字节*8 小数部分只能精确到后面15位，加上小数点前的一位，总的有效数字为16位。
```cgo
// 比如 10000018这个数，用 float32 的类型来表示的话，由于其有效位是7位
// 将10000018 表示成科学计数法，就是 1.0000018 * 10^7，能精确到小数点后面6位。

    // 临界
    var myfloat float32 = 10000018
    fmt.Println("myfloat: ", myfloat) // myfloat: 1.0000018e+07
    
    // 越界：由于其类型是 float32，精度不足，导致最后比较的结果是不相等（从小数点后第七位开始不精确）
    var myfloat01 float32 = 100000182
    var myfloat02 float32 = 100000187
    fmt.Println("myfloat: ", myfloat01) // myfloat: 1.00000184e+08
    fmt.Println("myfloat: ", myfloat01+5) // myfloat: 1.0000019e+08
    fmt.Println(myfloat02 == myfloat01+5) // false
    // 由于精度的问题，就会出现这种很怪异的现象，myfloat == myfloat +1 会返回 true
```

#### 1.2.2.2 字面量
    浮点字面值是浮点常量的 十进制 或 十六进制 表示形式

- 十进制浮点字面值：由 整数部分、小数点、小数部分 和 指数部分
- 十六进制浮点字面值：由 0x/0X前缀、整数部分、小数点、小数部分 和 指数部分

### 1.2.3. 复数类型
    复数有 实部 和 虚部

- complex64 的实部和虚部为 32 位
- complex128 的实部和虚部为 64 位

```cgo
    var c1 complex64  // 实部和虚部均为32位
	c1 = 1 + 2i
	fmt.Println(c1)  // (1+2i)
	
	var c2 complex128  // 实部和虚部均为64位
	c2 = 2 + 3i
	fmt.Println(c2)  // (2+3i)
```

### 1.2.4. 字符类型
    和C一样 把字符当作整数进行处理
    字符默认的类型为 rune

- byte 类型，它是 uint8 的一个类型别名，用于处理 8 位编码的字符集。例如，ASCII 和 Latin-1
- rune 类型，它是 int32 的类型别名，用于处理 Unicode。由于 Go 对 Unicode 字符的处理采用 UTF-8 编码方式，因此，可以是 rune 类型处理 UTF-8 字符

```cgo
    var ch rune = '你'  
    fmt.Println(ch)                            // 20320  
    fmt.Printf("Type: %T value: %c\n", ch, ch) // Type: int32 value: 你 
     
    var as byte = 'a'  
    fmt.Println(as)                            // 97  
    fmt.Printf("Type: %T value: %c\n", as, as) // Type: uint8 value: a
```

#### 1.2.4.1. 字符字面量
```cgo
    // Go 中字符的字面值使用单引号 '*' 标识。默认采用 rune 类型进行处理。例如
    var ch = 'a'   // 英文字符
    var ch2 = '天' // 中文字符
```
#### 1.2.4.2. 转义字符序列
    有一些 特殊符号，例如换行符，无法采用上述规则书写，因为它们是 不可见 的（非打印字符）或者是 无法从键盘输入 的。
    为了使程序可以处理字符集中的每一个字符，Go语言同样提供了特殊的字符表示方法：转义字符序列。
    转义字符序列共有两种形式：字符转义序列 和 数字转义序（有 八进制转义序列 和 十六进制转义序列 两种）。
    转义字符使用 \ 开头。

- 转义字符序列：字符转义序列使用 反斜杠(\) 和 一个 基本符号 表示
- 数字转义序列：从字符集中查找字符编码对应的八进制数和十六进制数。然后，使用 \ 和跟随其后的字符编码表示

## 1.3. string
    string 数据类型 用于 存储字符（文本）序列。
    字符串值必须用 双引号 引起来
    string 类型的默认值位空字符串("")
### 1.3.1. 多行字符串
```cgo
    var mutiline string = `
    白日依山尽，
    黄河入海流
    `
```
### 1.3.2. 字符串底层实现
    字符串是通过字节数组实现
    1 byte = 8 bit(八位二进制表示一个字节)
    UTF-8 编码下一个中文汉字由 3~4 个字节组成

```cgo
    var str string = "hello小飞"
    
    // Type: string, value: hello小飞, len: 11
	fmt.Printf("Type: %T, value: %v, len: %v\n", str, str, len(str)) 
```

## 1.4. 类型转换
    Go 只提供了 强制类型转换，没有隐式类型转换。该语法只能在 两个类型之间支持相互转换 的时候使用

```cgo
    var a int8 = 10
    var b int16 = int16(a) // 不能直接用 int8 的变量赋值给 int16    
    b = int16(a)  // 可以这样
```

# 2. 指针
    Go语言中的指针不能进行偏移和运算，因此我们说Go语言的指针是只读的。

- &：用于取地址
- *：根据地址取值

```cgo
    res := struct {
		Content string // 值类型
		Status  *uint8 // 指针类型：允许为0
		Reason  *string // 指针类型：允许为""
	}{
		Content: v.Content,
		Status:  &status, // 指针类型的元素在被赋值时 应该用&value的形式
		Reason:  &v.AuditReason,
	}
```

# 3. 类型转换

## 3.1. int 转 uint 数据出错
    int 首位表示正负 当为负值时 转换成uint 出现数据不正确的错误 
```cgo
// 代码示例
func getDeadlyPoints(userID uint, nowPoint uint32, expireTime int64) uint32 {
	// 获取过期时间(前年年初)
	res := struct {
		Point uint32 // 这两年挣的积分
	}{}
	
	// ... 次数省略其他的代码
	
	// 即将过期的积分 = 当前积分 - 这两年挣的积分
	// DeadlyPoints := int(nowPoint - res.Point) 这样改是不对的 需要将两个数据分别int之后相减
	DeadlyPoints := int(nowPoint) - int(res.Point)
	if DeadlyPoints < 0 {
		DeadlyPoints = 0
	}
	return uint32(DeadlyPoints) // 最后得到的数据 确保是 正数 在进行uint
}
```

## 3.2. float 转 int 数据出错
    在强制转换过程中，小数部分会被直接截断，只保留整数部分。
    float比int范围大 不会发生溢出，但是丢失精度会导致结果不同 
```cgo
// 代码示例
float a := 0.5 
b := (int)a // b =0 直接截掉小数部分 ，没有进行四舍五入
```

# 4. 为什么时间戳要用 int64 

- 范围足够大：int64 能够表示的数值范围足够涵盖大多数常见的时间戳范围，从 1970 年 1 月 1 日（Unix 纪元）到很久的未来。
- 精度和准确性：可以准确表示到微秒甚至纳秒级别的时间精度，满足大多数应用对时间精度的要求。
- 跨平台一致性：int64 在不同的操作系统和硬件架构上具有一致的行为和表示，使得代码在不同环境中的行为更可预测。
- 方便计算和比较：整数类型在进行时间的计算（如时间差）和比较操作时通常更直观和高效。
- 与数据库和网络通信的兼容性：许多数据库和网络协议也常使用 64 位整数来表示时间戳，方便数据的存储、传输和转换。

# 5. get请求

## 5.1. get接口传递数组参数
```cgo
// 举例：可以批量选择Tag

// 可以接受 Tag[]:1,Tag[]:2 这样的数据
input := struct {
    Tag   []uint `form:"Tag[]"`
}{}

// 如果参数中Tag的长度 大于0 将在数据库中 查找 tag.id 在 input.Tag 数组中的 数据
if len(input.Tag) > 0 {
    tx.Where("tag.id IN (?)", input.Tag)
}

```

## 5.2. GET请求为什么被认为不安全

### 5.2.1. get为什么不安全
- 参数暴露在 URL 中：GET 请求的参数是附加在 URL 中的，这意味着这些参数会在浏览器的地址栏中可见，并且可能会被服务器、代理服务器、浏览器等记录在访问日志中。如果参数包含敏感信息（如密码、个人身份信息等），就存在信息泄露的风险。
- 可缓存性：浏览器和代理服务器可能会缓存 GET 请求的响应。这可能导致一些敏感数据被意外存储和传播。
- 不可更改性：GET 请求通常被认为是只读的操作，不应用于修改服务器上的数据。然而，如果服务器端没有正确处理，可能会因为 GET 请求而意外地修改数据，这违反了 GET 请求的预期用途和最佳实践。
- 长度限制：URL 通常有长度限制，这可能会限制能够传递的数据量。

### 5.2.2. post为什么更安全
- 不可缓存性：默认情况下，POST 请求的响应通常不会被浏览器和中间代理服务器缓存，减少了数据被意外存储和传播的可能性。
- 数据量限制较小：POST 请求可以发送更大量的数据，因为它不受 URL 长度的限制。

### 5.2.3. 浏览器和代理服务器为什么会缓存get请求的响应
    浏览器和代理服务器会缓存 GET 请求的响应，主要是出于性能和效率的考虑。

1. 缓存的目的是为了减少重复的网络请求，加快页面加载速度，降低服务器负载。当浏览器或代理服务器接收到一个 GET 请求时，如果之前已经处理过相同的请求并且响应满足一定的缓存规则（例如响应头中的 Cache-Control、Expires 等字段指定了可缓存的条件和时间），它们就会直接使用缓存的响应，而不再向服务器重新发送请求。

2. 对于 GET 请求，由于其通常被认为是 用于获取不会改变的数据，所以更适合进行缓存。而 POST 请求通常用于修改数据或执行具有副作用的操作，其响应的结果可能因每次请求的参数不同而变化，因此不太适合被缓存。

3. 但缓存机制也可能导致一些问题，比如数据更新不及时，所以在实际开发中，需要通过正确设置响应头来控制缓存策略，以确保用户获取到最新和准确的数据。

### 5.2.4. 在什么情况下 项目中要尽量避免用到get
- 涉及敏感信息的传递：如用户密码、个人身份信息、金融交易数据等。因为这些信息会暴露在 URL 中，增加了安全风险。
- 数据修改或写入操作：例如创建、更新或删除数据。GET 请求不应用于执行这些可能改变服务器状态的操作，应使用 POST、PUT 或 DELETE 方法。
- 大量数据的传输：由于 URL 长度的限制，GET 请求不适合传输大量的数据。
- 不确定性或动态的请求参数：如果请求参数的值经常变化，或者其组合和顺序不固定，使用 GET 可能导致难以管理和理解的 URL。
- 违反幂等性原则的操作：幂等性意味着多次执行相同的 请求应该产生相同的结果。对于非幂等性的操作，不应使用 GET。
- 不符合缓存策略：如果数据需要实时更新且不应被缓存，使用 GET 可能导致缓存问题，此时应选择其他方法。

# 6. fmt和log
    两者都能将数据以某种形式展示出来。           
    在一些情况下，log 的性能可能略优于 fmt ，特别是在频繁的日志记录场景中。

## 6.1. fmt
- fmt 主要用于格式化输出数据，更侧重于将数据以特定的格式打印到标准输出（通常是终端）
- 默认是标准输出

## 6.2. log
- 更侧重于记录日志信息，包括时间戳、日志级别等。
- 支持不同的日志级别，如 Info、Warning、Error 等。
- 输出的日志通常包含更多的上下文信息，如时间戳。
- 可以将日志输出到不同的目的地，例如文件。

## 6.3. 总结
    总结来说的话 个人用log会更多一些 所以一般在调试的时候也会是用log而很少用到fmt

# 7. defer啥时候调用
    后进先出的形式 在每次函数执行结束时 执行 也就是说，当包含 defer 语句的函数即将返回时，无论是正常返回还是因为出现异常而返回，defer 注册的语句都会被执行。

## 7.1. 循环读入不同的文件 需要再循环内 多次执行对不同文件的defer file.Close()吗
    在循环中读入不同的文件时，通常需要在每次循环中为当前正在操作的文件执行 defer file.Close() 。这样可以确保在每次循环迭代结束时，当前文件能被正确关闭，及时释放资源，并且即使在循环内部出现错误或提前返回的情况下，也能保证文件被关闭。

    需要注意的是，如果循环的执行频率很高或者文件操作很频繁，可能会因为大量的 defer 操作带来一些性能开销。在这种情况下，可以考虑在循环结束后手动关闭文件，但要确保在任何情况下都能正确关闭文件以避免资源泄漏。
