# 1. 数据类型
    Go 是 静态类型的，这意味着 一旦定义了变量类型，它就只能存储该类型的数据。
## 1.1. bool 类型
    1. 表示布尔值，只有 true 或 false 两个取值
    2. 默认值为 false
```cgo
    var b1 bool = true //带有初始值的 类型声明
    var b2 = true      // 带初始值的 无类型声明
    var b3 bool        // 不带初始值的类型声明  默认为 false
    b4 := true         // 自动类型推断
    
    fmt.Println(b1) // true
    fmt.Println(b2) // true
    fmt.Println(b3) // false
    fmt.Println(b4) // true
```

## 1.2. 数值
     整数类型、浮点类型、复数类型 和 字符类型
### 1.2.1. 整数
    整数数据类型 用于 存储没有小数的整数，如 35、-50 或 1345000
#### ①. int
    用 int 关键字之一声明的有符号整数可以存储正数和负数

    因为有一位表示正负(0/1)，故取值范围应在(2的n-1次方)
    又因为0占正数的一个位置所以最大取值是(2的n-1次方)-1
##### a. int
    大小取决于平台（32位平台占32位，64位平台占64位）
##### b. int8
    8位：取值范围在[-128, 127]
##### c. int16
    16位：取值范围在[-32768, 32767]
##### d. int32
##### e. int64
##### f. rune32
    32位：是int32的别名用于处理 Unicode字符

#### ②. uint
    使用 uint 关键字声明的无符号整数只能存储非负值
##### a. uint
    大小取决于平台（32位平台占32位，64位平台占64位）
##### b. uint8
    8位：取值范围在[0, 255]
##### c. uint16
    16位：取值范围在[0, 65535]
##### d. uint32
##### e. uint64
##### f. byte
    8位：uint8 的一个 别名
##### g. uintptr
    取决于平台：表示指针类型

#### ③. 整数字面量
    整数字面值是表示整数常量的数字序列。可选前缀设置非十进制基数。为了便于阅读，下划线字符 _ 可能出现在 基本前缀之后 或 连续数字之间；这样的下划线不会改变字面值
- 0b 或 0B 表示二进制序列
- 0o 或 0O 表示八进制序列
- 0x 或 0X 表示十六进制。在十六进制文字中,字母a到f表示值10到15
- 单个 0 被视为十进制零

### 1.2.2. 浮点类型
    浮点数据类型 用于 存储带小数点的正数和负数
    浮点数在计算机中的表示方法遵循IEEE 754标准
    浮点类型的 默认类型是 float64。如果不指定类型，则类型为 float64
    float32 与 float64 类型的变量不能相互赋值。是两个不同的数据类型

#### 1.2.2.1 介绍
- float32：32位 = 4字节*8 小数部分只能精确到后面6位，加上小数点前的一位，总的有效数字为7位。
- float64：64位 = 8字节*8 小数部分只能精确到后面15位，加上小数点前的一位，总的有效数字为16位。
```cgo
// 比如 10000018这个数，用 float32 的类型来表示的话，由于其有效位是7位
// 将10000018 表示成科学计数法，就是 1.0000018 * 10^7，能精确到小数点后面6位。

    // 临界
    var myfloat float32 = 10000018
    fmt.Println("myfloat: ", myfloat) // myfloat: 1.0000018e+07
    
    // 越界：由于其类型是 float32，精度不足，导致最后比较的结果是不相等（从小数点后第七位开始不精确）
    var myfloat01 float32 = 100000182
    var myfloat02 float32 = 100000187
    fmt.Println("myfloat: ", myfloat01) // myfloat: 1.00000184e+08
    fmt.Println("myfloat: ", myfloat01+5) // myfloat: 1.0000019e+08
    fmt.Println(myfloat02 == myfloat01+5) // false
    // 由于精度的问题，就会出现这种很怪异的现象，myfloat == myfloat +1 会返回 true
```

#### 1.2.2.2 字面量
    浮点字面值是浮点常量的 十进制 或 十六进制 表示形式

- 十进制浮点字面值：由 整数部分、小数点、小数部分 和 指数部分
- 十六进制浮点字面值：由 0x/0X前缀、整数部分、小数点、小数部分 和 指数部分

### 1.2.3. 复数类型
    复数有 实部 和 虚部

- complex64 的实部和虚部为 32 位
- complex128 的实部和虚部为 64 位

```cgo
    var c1 complex64  // 实部和虚部均为32位
	c1 = 1 + 2i
	fmt.Println(c1)  // (1+2i)
	
	var c2 complex128  // 实部和虚部均为64位
	c2 = 2 + 3i
	fmt.Println(c2)  // (2+3i)
```

### 1.2.4. 字符类型
    和C一样 把字符当作整数进行处理
    字符默认的类型为 rune

- byte 类型，它是 uint8 的一个类型别名，用于处理 8 位编码的字符集。例如，ASCII 和 Latin-1
- rune 类型，它是 int32 的类型别名，用于处理 Unicode。由于 Go 对 Unicode 字符的处理采用 UTF-8 编码方式，因此，可以是 rune 类型处理 UTF-8 字符

```cgo
    var ch rune = '你'  
    fmt.Println(ch)                            // 20320  
    fmt.Printf("Type: %T value: %c\n", ch, ch) // Type: int32 value: 你 
     
    var as byte = 'a'  
    fmt.Println(as)                            // 97  
    fmt.Printf("Type: %T value: %c\n", as, as) // Type: uint8 value: a
```

#### 1.2.4.1. 字符字面量
```cgo
    // Go 中字符的字面值使用单引号 '*' 标识。默认采用 rune 类型进行处理。例如
    var ch = 'a'   // 英文字符
    var ch2 = '天' // 中文字符
```
#### 1.2.4.2. 转义字符序列
    有一些 特殊符号，例如换行符，无法采用上述规则书写，因为它们是 不可见 的（非打印字符）或者是 无法从键盘输入 的。
    为了使程序可以处理字符集中的每一个字符，Go语言同样提供了特殊的字符表示方法：转义字符序列。
    转义字符序列共有两种形式：字符转义序列 和 数字转义序（有 八进制转义序列 和 十六进制转义序列 两种）。
    转义字符使用 \ 开头。

- 转义字符序列：字符转义序列使用 反斜杠(\) 和 一个 基本符号 表示
- 数字转义序列：从字符集中查找字符编码对应的八进制数和十六进制数。然后，使用 \ 和跟随其后的字符编码表示

## 1.3. string
    string 数据类型 用于 存储字符（文本）序列。
    字符串值必须用 双引号 引起来
    string 类型的默认值位空字符串("")
### 1.3.1. 多行字符串
```cgo
    var mutiline string = `
    白日依山尽，
    黄河入海流
    `
```
### 1.3.2. 字符串底层实现
    字符串是通过字节数组实现
    1 byte = 8 bit(八位二进制表示一个字节)
    UTF-8 编码下一个中文汉字由 3~4 个字节组成

```cgo
    var str string = "hello小飞"
    
    // Type: string, value: hello小飞, len: 11
	fmt.Printf("Type: %T, value: %v, len: %v\n", str, str, len(str)) 
```

## 1.4. 类型转换
    Go 只提供了 强制类型转换，没有隐式类型转换。该语法只能在 两个类型之间支持相互转换 的时候使用

```cgo
    var a int8 = 10
    var b int16 = int16(a) // 不能直接用 int8 的变量赋值给 int16    
    b = int16(a)  // 可以这样
```

# 2. 指针
    Go语言中的指针不能进行偏移和运算，因此我们说Go语言的指针是只读的。

- &：用于取地址
- *：根据地址取值

```cgo
    res := struct {
		Content string // 值类型
		Status  *uint8 // 指针类型：允许为0
		Reason  *string // 指针类型：允许为""
	}{
		Content: v.Content,
		Status:  &status, // 指针类型的元素在被赋值时 应该用&value的形式
		Reason:  &v.AuditReason,
	}
```